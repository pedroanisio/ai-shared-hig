<?xml version="1.0" ?>
<pattern xmlns="http://universal-corpus.org/schema/v1" id="" version="1.1">
  <metadata>
    <name/>
    <category>pattern</category>
    <status>stable</status>
    <complexity>medium</complexity>
  </metadata>
  <definition>
    <tuple-notation format="latex">$I = (graph, cache, invalidate, recompute)$</tuple-notation>
    <components>
      <component>
        <name>graph</name>
        <type>DAG⟨Node, Dependency⟩</type>
        <notation>graph</notation>
        <description>computation dependency graph</description>
      </component>
      <component>
        <name>cache</name>
        <type>Map⟨Node, Value⟩</type>
        <notation>cache</notation>
        <description>stores computed values</description>
      </component>
      <component>
        <name>invalidate</name>
        <type>Node → Set⟨Node⟩</type>
        <notation>invalidate</notation>
        <description>marks affected nodes</description>
      </component>
      <component>
        <name>recompute</name>
        <type>Node → Value</type>
        <notation>recompute</notation>
        <description>recomputes a single node</description>
      </component>
    </components>
  </definition>
  <type-definitions>
    <type-def>
      <name>Node</name>
      <definition format="latex">(id: String, compute: Inputs → Output, dependencies: Set⟨Node⟩)</definition>
    </type-def>
    <type-def>
      <name>Dependency</name>
      <definition format="latex">(source: Node, target: Node)</definition>
    </type-def>
  </type-definitions>
  <properties>
    <property id="P.F2.3.1">
      <name>Minimal Recomputation</name>
      <formal-spec format="latex">∀n ∈ graph: recompute(n) ⇔ (invalidated(n) ∨ ∃d ∈ dependencies(n): invalidated(d))
Only recompute what changed</formal-spec>
    </property>
    <property id="P.F2.3.2">
      <name>Topological Order</name>
      <formal-spec format="latex">∀n₁, n₂: dependency(n₁, n₂) ⇒ compute_order(n₁) &lt; compute_order(n₂)</formal-spec>
    </property>
    <property id="P.F2.3.3">
      <name>Cache Consistency</name>
      <formal-spec format="latex">∀n ∈ graph: cache[n] = last_computed_value(n) ∨ cache[n] = ⊥</formal-spec>
    </property>
  </properties>
  <operations>
    <operation>
      <name>Update</name>
      <signature>update(changed: Set⟨Node⟩) → Effect</signature>
      <formal-definition format="latex">```
   update(changed: Set⟨Node⟩) → Effect
   = affected := transitive_dependencies(changed)
     invalidate(affected)
     sorted := topological_sort(affected)
     for node in sorted:
       cache[node] := recompute(node)</formal-definition>
    </operation>
    <operation>
      <name>Invalidate</name>
      <signature>invalidate(nodes: Set⟨Node⟩) → Set⟨Node⟩</signature>
      <formal-definition format="latex">```
   invalidate(nodes: Set⟨Node⟩) → Set⟨Node⟩
   = invalidated := nodes
     for node in nodes:
       for dependent in dependents(node):
         invalidated := invalidated ∪ invalidate({dependent})
     return invalidated</formal-definition>
    </operation>
    <operation>
      <name>Recompute</name>
      <signature>recompute(node: Node) → Value</signature>
      <formal-definition format="latex">```
   recompute(node: Node) → Value
   = inputs := {cache[d] : d ∈ dependencies(node)}
     return node.compute(inputs)</formal-definition>
    </operation>
  </operations>
  <manifestations>
    <manifestation>
      <name>Spreadsheet recalculation</name>
    </manifestation>
    <manifestation>
      <name>Build systems</name>
      <description>Make, Bazel</description>
    </manifestation>
    <manifestation>
      <name>Reactive frameworks</name>
      <description>React, Vue</description>
    </manifestation>
    <manifestation>
      <name>Query optimization</name>
    </manifestation>
    <manifestation>
      <name>Dataflow programming</name>
    </manifestation>
  </manifestations>
</pattern>
