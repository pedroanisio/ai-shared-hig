<?xml version="1.0" ?>
<pattern xmlns="http://universal-corpus.org/schema/v1" id="P50" version="1.1">
  <metadata>
    <name>Form Dependency Pattern</name>
    <category>pattern</category>
    <status>stable</status>
    <complexity>medium</complexity>
  </metadata>
  <definition>
    <tuple-notation format="latex">$D = (fields, deps, update, cascade)$</tuple-notation>
    <components>
      <component>
        <name>fields</name>
        <type>Map‚ü®String, Field‚ü©</type>
        <notation>fields</notation>
        <description>form fields</description>
      </component>
      <component>
        <name>deps</name>
        <type>Map‚ü®String, Set‚ü®String‚ü©‚ü©</type>
        <notation>deps</notation>
        <description>defines dependencies</description>
      </component>
      <component>
        <name>update</name>
        <type>String √ó Value ‚Üí Effect</type>
        <notation>update</notation>
        <description>propagates changes</description>
      </component>
      <component>
        <name>cascade</name>
        <type>ùîπ</type>
        <notation>cascade</notation>
        <description>enables cascading updates</description>
      </component>
    </components>
  </definition>
  <type-definitions>
    <type-def>
      <name>Dependency</name>
      <definition format="latex">(source: String, targets: Set‚ü®String‚ü©,</definition>
    </type-def>
  </type-definitions>
  <properties>
    <property id="P.P50.1">
      <name>Dependency Graph</name>
      <formal-spec format="latex">deps forms a DAG (no circular dependencies)</formal-spec>
    </property>
    <property id="P.P50.2">
      <name>Automatic Updates</name>
      <formal-spec format="latex">change(field_A) ‚àß field_B ‚àà deps[field_A] ‚áí update(field_B)</formal-spec>
    </property>
    <property id="P.P50.3">
      <name>Conditional Visibility</name>
      <formal-spec format="latex">visible(field) = evaluate(visibility_condition, form_data)</formal-spec>
    </property>
    <property id="P.P50.4">
      <name>Value Computation</name>
      <formal-spec format="latex">computed_field.value = compute(dependencies.values)</formal-spec>
    </property>
  </properties>
  <operations>
    <operation>
      <name>Register Dependency</name>
      <signature>add_dependency(source: String, target: String, rule: Rule) ‚Üí Effect</signature>
      <formal-definition format="latex">```
   add_dependency(source: String, target: String, rule: Rule) ‚Üí Effect
   = deps[source] := deps[source] ‚à™ {target}
     rules[(source, target)] := rule
     validate_acyclic(deps)</formal-definition>
    </operation>
    <operation>
      <name>Update Field</name>
      <signature>update_field(field: String, value: Value) ‚Üí Effect</signature>
      <formal-definition format="latex">```
   update_field(field: String, value: Value) ‚Üí Effect
   = fields[field].value := value
     
     if cascade:
       for target in deps[field]:
         rule := rules[(field, target)]
         new_value := rule(value)
         update_field(target, new_value)</formal-definition>
    </operation>
    <operation>
      <name>Compute Derived Value</name>
      <signature>compute_derived(field: String) ‚Üí Value</signature>
      <formal-definition format="latex">```
   compute_derived(field: String) ‚Üí Value
   = sources := {f : field ‚àà deps[f]}
     values := map(sources, Œªf: fields[f].value)
     compute_function[field](values)</formal-definition>
    </operation>
    <operation>
      <name>Conditional Visibility</name>
      <signature/>
      <formal-definition format="latex">```
   Field "Other" visible only if "Category" = "Other"
   
   deps["category"] := {"other_field"}
   rules[("category", "other_field")] := 
     Œªval: {visible: val = "Other"}</formal-definition>
    </operation>
    <operation>
      <name>Value Computation</name>
      <signature/>
      <formal-definition format="latex">```
   Total = Subtotal + Tax
   
   deps["subtotal"] := {"total"}
   deps["tax"] := {"total"}
   rules[("subtotal"|"tax", "total")] := 
     Œª_: subtotal + tax</formal-definition>
    </operation>
    <operation>
      <name>Cascading Defaults</name>
      <signature>Country ‚Üí State ‚Üí City</signature>
      <formal-definition format="latex">```
   Country ‚Üí State ‚Üí City
   
   Changing country resets state and city
   Changing state resets city</formal-definition>
    </operation>
    <operation>
      <name>Dynamic Options</name>
      <signature>Category ‚Üí Subcategory options</signature>
      <formal-definition format="latex">```
   Category ‚Üí Subcategory options
   
   deps["category"] := {"subcategory"}
   rules[("category", "subcategory")] := 
     Œªcat: {options: get_subcategories(cat)}</formal-definition>
    </operation>
  </operations>
  <manifestations>
    <manifestation>
      <name>Address forms</name>
      <description>country‚Üístate‚Üícity</description>
    </manifestation>
    <manifestation>
      <name>Product configurators</name>
    </manifestation>
    <manifestation>
      <name>Tax calculators</name>
    </manifestation>
    <manifestation>
      <name>Dynamic pricing forms</name>
    </manifestation>
    <manifestation>
      <name>Conditional survey questions</name>
    </manifestation>
  </manifestations>
</pattern>
