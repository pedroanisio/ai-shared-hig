<?xml version='1.0' encoding='utf-8'?>
<ns0:pattern xmlns:ns0="http://universal-corpus.org/schema/v1" id="F4.4" version="1.1">
  <ns0:metadata>
    <ns0:name />
    <ns0:category>pattern</ns0:category>
    <ns0:status>stable</ns0:status>
    <ns0:complexity>medium</ns0:complexity>
  </ns0:metadata>
  <ns0:definition>
    <ns0:tuple-notation format="latex">$M = (query, compute, cache, refresh)$</ns0:tuple-notation>
    <ns0:components>
      <ns0:component>
        <ns0:name>query</ns0:name>
        <ns0:type>Query</ns0:type>
        <ns0:notation>query</ns0:notation>
        <ns0:description>defines the view computation</ns0:description>
      </ns0:component>
      <ns0:component>
        <ns0:name>compute</ns0:name>
        <ns0:type>Data → Result</ns0:type>
        <ns0:notation>compute</ns0:notation>
        <ns0:description>executes the query</ns0:description>
      </ns0:component>
      <ns0:component>
        <ns0:name>cache</ns0:name>
        <ns0:type>Result</ns0:type>
        <ns0:notation>cache</ns0:notation>
        <ns0:description>stores computed result</ns0:description>
      </ns0:component>
      <ns0:component>
        <ns0:name>refresh</ns0:name>
        <ns0:type>Trigger → Effect</ns0:type>
        <ns0:notation>refresh</ns0:notation>
        <ns0:description>updates materialized view</ns0:description>
      </ns0:component>
    </ns0:components>
  </ns0:definition>
  <ns0:type-definitions>
    <ns0:type-def>
      <ns0:name>Query</ns0:name>
      <ns0:definition format="latex">(select: Projection, from: Source, where: Predicate, aggregate: Function)</ns0:definition>
    </ns0:type-def>
    <ns0:type-def>
      <ns0:name>Result</ns0:name>
      <ns0:definition format="latex">Computed and cached query result</ns0:definition>
    </ns0:type-def>
    <ns0:type-def>
      <ns0:name>Trigger</ns0:name>
      <ns0:definition format="latex">OnDemand | OnChange | Scheduled(interval: Time)</ns0:definition>
    </ns0:type-def>
    <ns0:type-def>
      <ns0:name>Staleness</ns0:name>
      <ns0:definition format="latex">Time since last refresh</ns0:definition>
    </ns0:type-def>
  </ns0:type-definitions>
  <ns0:properties>
    <ns0:property id="P.F4.4.1">
      <ns0:name>Consistency Eventually</ns0:name>
      <ns0:formal-spec format="latex">∀m ∈ MaterializedViews: after_refresh(m) ⇒
cache(m) = compute(query(m), current_data)</ns0:formal-spec>
    </ns0:property>
    <ns0:property id="P.F4.4.2">
      <ns0:name>Performance Trade-off</ns0:name>
      <ns0:formal-spec format="latex">read_cost(materialized_view) &lt;&lt; read_cost(base_query) ∧
maintenance_cost(materialized_view) &gt; 0</ns0:formal-spec>
    </ns0:property>
    <ns0:property id="P.F4.4.3">
      <ns0:name>Staleness Bound</ns0:name>
      <ns0:formal-spec format="latex">∀m ∈ MaterializedViews: staleness(m) ≤ max_staleness(m) ∨ trigger_refresh(m)</ns0:formal-spec>
    </ns0:property>
  </ns0:properties>
  <ns0:operations>
    <ns0:operation>
      <ns0:name>Read</ns0:name>
      <ns0:signature>read(view: MaterializedView) → Result</ns0:signature>
      <ns0:formal-definition format="latex">```
   read(view: MaterializedView) → Result
   = if stale(view):
       if refresh_strategy = OnDemand:
         refresh(view)
     return cache[view]</ns0:formal-definition>
    </ns0:operation>
    <ns0:operation>
      <ns0:name>Refresh</ns0:name>
      <ns0:signature>refresh(view: MaterializedView) → Effect</ns0:signature>
      <ns0:formal-definition format="latex">```
   refresh(view: MaterializedView) → Effect
   = start_transaction()
     new_result := compute(view.query, current_data)
     cache[view] := new_result
     last_refreshed[view] := now()
     commit_transaction()
     notify_subscribers(view)</ns0:formal-definition>
    </ns0:operation>
    <ns0:operation>
      <ns0:name>Incremental Refresh</ns0:name>
      <ns0:signature>incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect</ns0:signature>
      <ns0:formal-definition format="latex">```
   incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect
   = affected := filter_relevant_changes(changes, view.query)
     if empty(affected):
       return  // No update needed
     
     if can_update_incrementally(view, affected):
       cache[view] := apply_incremental_update(cache[view], affected)
     else:
       refresh(view)  // Full refresh</ns0:formal-definition>
    </ns0:operation>
  </ns0:operations>
  <ns0:manifestations>
    <ns0:manifestation>
      <ns0:name>Database materialized views</ns0:name>
    </ns0:manifestation>
    <ns0:manifestation>
      <ns0:name>Cached aggregations</ns0:name>
    </ns0:manifestation>
    <ns0:manifestation>
      <ns0:name>Precomputed reports</ns0:name>
    </ns0:manifestation>
    <ns0:manifestation>
      <ns0:name>Search indices</ns0:name>
    </ns0:manifestation>
    <ns0:manifestation>
      <ns0:name>Dashboard metrics</ns0:name>
    </ns0:manifestation>
  </ns0:manifestations>
</ns0:pattern>