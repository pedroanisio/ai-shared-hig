<?xml version="1.0" ?>
<pattern xmlns="http://universal-corpus.org/schema/v1" id="" version="1.1">
  <metadata>
    <name/>
    <category>pattern</category>
    <status>stable</status>
    <complexity>medium</complexity>
  </metadata>
  <definition>
    <tuple-notation format="latex">$M = (query, compute, cache, refresh)$</tuple-notation>
    <components>
      <component>
        <name>query</name>
        <type>Query</type>
        <notation>query</notation>
        <description>defines the view computation</description>
      </component>
      <component>
        <name>compute</name>
        <type>Data → Result</type>
        <notation>compute</notation>
        <description>executes the query</description>
      </component>
      <component>
        <name>cache</name>
        <type>Result</type>
        <notation>cache</notation>
        <description>stores computed result</description>
      </component>
      <component>
        <name>refresh</name>
        <type>Trigger → Effect</type>
        <notation>refresh</notation>
        <description>updates materialized view</description>
      </component>
    </components>
  </definition>
  <type-definitions>
    <type-def>
      <name>Query</name>
      <definition format="latex">(select: Projection, from: Source, where: Predicate, aggregate: Function)</definition>
    </type-def>
    <type-def>
      <name>Result</name>
      <definition format="latex">Computed and cached query result</definition>
    </type-def>
    <type-def>
      <name>Trigger</name>
      <definition format="latex">OnDemand | OnChange | Scheduled(interval: Time)</definition>
    </type-def>
    <type-def>
      <name>Staleness</name>
      <definition format="latex">Time since last refresh</definition>
    </type-def>
  </type-definitions>
  <properties>
    <property id="P.F4.4.1">
      <name>Consistency Eventually</name>
      <formal-spec format="latex">∀m ∈ MaterializedViews: after_refresh(m) ⇒
cache(m) = compute(query(m), current_data)</formal-spec>
    </property>
    <property id="P.F4.4.2">
      <name>Performance Trade-off</name>
      <formal-spec format="latex">read_cost(materialized_view) &lt;&lt; read_cost(base_query) ∧
maintenance_cost(materialized_view) &gt; 0</formal-spec>
    </property>
    <property id="P.F4.4.3">
      <name>Staleness Bound</name>
      <formal-spec format="latex">∀m ∈ MaterializedViews: staleness(m) ≤ max_staleness(m) ∨ trigger_refresh(m)</formal-spec>
    </property>
  </properties>
  <operations>
    <operation>
      <name>Read</name>
      <signature>read(view: MaterializedView) → Result</signature>
      <formal-definition format="latex">```
   read(view: MaterializedView) → Result
   = if stale(view):
       if refresh_strategy = OnDemand:
         refresh(view)
     return cache[view]</formal-definition>
    </operation>
    <operation>
      <name>Refresh</name>
      <signature>refresh(view: MaterializedView) → Effect</signature>
      <formal-definition format="latex">```
   refresh(view: MaterializedView) → Effect
   = start_transaction()
     new_result := compute(view.query, current_data)
     cache[view] := new_result
     last_refreshed[view] := now()
     commit_transaction()
     notify_subscribers(view)</formal-definition>
    </operation>
    <operation>
      <name>Incremental Refresh</name>
      <signature>incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect</signature>
      <formal-definition format="latex">```
   incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect
   = affected := filter_relevant_changes(changes, view.query)
     if empty(affected):
       return  // No update needed
     
     if can_update_incrementally(view, affected):
       cache[view] := apply_incremental_update(cache[view], affected)
     else:
       refresh(view)  // Full refresh</formal-definition>
    </operation>
  </operations>
  <manifestations>
    <manifestation>
      <name>Database materialized views</name>
    </manifestation>
    <manifestation>
      <name>Cached aggregations</name>
    </manifestation>
    <manifestation>
      <name>Precomputed reports</name>
    </manifestation>
    <manifestation>
      <name>Search indices</name>
    </manifestation>
    <manifestation>
      <name>Dashboard metrics</name>
    </manifestation>
  </manifestations>
</pattern>
