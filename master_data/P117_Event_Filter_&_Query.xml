<?xml version="1.0" ?>
<pattern xmlns="http://universal-corpus.org/schema/v1" id="P117" version="1.1">
  <metadata>
    <name>Event Filter &amp; Query</name>
    <category>pattern</category>
    <status>stable</status>
    <complexity>medium</complexity>
  </metadata>
  <definition>
    <tuple-notation format="latex">$Q_{event} = (Stream, Filters, Query_{language}, Results) : \text{Events} \to \text{Events}_{filtered}$</tuple-notation>
    <components>
      <component>
        <name>Stream</name>
        <type>Stream⟨Event⟩</type>
        <notation>Stream</notation>
        <description>event stream to be queried</description>
      </component>
      <component>
        <name>Filters</name>
        <type>Set⟨Predicate⟩</type>
        <notation>Filters</notation>
        <description>collection of filter predicates</description>
      </component>
      <component>
        <name>Query_{language}</name>
        <type>QueryLanguage</type>
        <notation>Query_{language}</notation>
        <description>domain-specific query language for events</description>
      </component>
      <component>
        <name>Results</name>
        <type>Stream⟨Event⟩</type>
        <notation>Results</notation>
        <description>filtered/queried result stream</description>
      </component>
    </components>
  </definition>
  <type-definitions>
      <type-def>
        <name>Predicate</name>
        <definition>$\text{Predicate} = \text{Event} \to \text{Boolean}$ (filter function)</definition>
      </type-def>
      <type-def>
        <name>QueryLanguage</name>
        <definition>$\text{QueryLanguage} = \{\text{SQL-like}, \text{CEP}, \text{pattern-matching}, \text{temporal-logic}\}$</definition>
      </type-def>
      <type-def>
        <name>Query</name>
        <definition>$\text{Query} = (\text{select}, \text{where}, \text{window}, \text{aggregate})$</definition>
      </type-def>
    </type-definitions>
  <properties>
    <property id="P.P117.1">
      <name>Filter Composability</name>
      <formal-spec format="latex">$\forall f_1, f_2 \in Filters : \text{compose}(f_1, f_2) = \lambda e. f_1(e) \land f_2(e)$ (conjunction)</formal-spec>
    </property>
    <property id="P.P117.2">
      <name>Query Selectivity</name>
      <formal-spec format="latex">$\forall q \in \text{Queries} : |\text{Results}(q)| \leq |\text{Stream}|$ (filtering reduces size)</formal-spec>
    </property>
    <property id="P.P117.3">
      <name>Streaming Execution</name>
      <formal-spec format="latex">$\forall e \in Stream : \text{latency}(\text{filter}(e)) &lt; \Delta t_{threshold}$ (real-time filtering)</formal-spec>
    </property>
    <property id="P.P117.4">
      <name>Pattern Matching Expressiveness</name>
      <formal-spec format="latex">$\text{Query}_{language} \supseteq \{\text{SEQ}, \text{AND}, \text{OR}, \text{NOT}, \text{WITHIN}\}$ (temporal operators)</formal-spec>
    </property>
  </properties>
  <operations>
    <operation>
      <name>Apply Filter</name>
      <signature>applyFilter: Stream⟨Event⟩ × Predicate → Stream⟨Event⟩</signature>
      <formal-definition format="latex">$\text{applyFilter}(S, p) = \{e \in S \mid p(e) = \text{true}\}$</formal-definition>
    </operation>
    <operation>
      <name>Execute Query</name>
      <signature>executeQuery: Stream⟨Event⟩ × Query → Stream⟨Event⟩</signature>
      <formal-definition format="latex">$\text{executeQuery}(S, q) = \text{Results}$ where
  $\text{filtered} = \{e \in S \mid q.\text{where}(e)\}$
  $\text{windowed} = \text{window}(\text{filtered}, q.\text{window})$
  $\text{Results} = q.\text{select}(\text{windowed})$</formal-definition>
    </operation>
    <operation>
      <name>Pattern Match</name>
      <signature>matchPattern: Stream⟨Event⟩ × Pattern → Stream⟨Match⟩</signature>
      <formal-definition format="latex">$\text{matchPattern}(S, pat) = \{m \mid m \text{ satisfies } pat \land m \subseteq S\}$
where Pattern can be regular expression or temporal logic formula</formal-definition>
    </operation>
  </operations>
  <dependencies>
    <requires>
      <pattern-ref>P22</pattern-ref>
    </requires>
    <uses>
      <pattern-ref>P53</pattern-ref>
      <pattern-ref>P104</pattern-ref>
      <pattern-ref>P112</pattern-ref>
      <pattern-ref>P116</pattern-ref>
    </uses>
  </dependencies>
  <manifestations>
    <manifestation>
      <name>Apache Flink CEP (Complex Event Processing)</name>
      <description>pattern matching on event streams</description>
    </manifestation>
    <manifestation>
      <name>Kafka Streams filtering</name>
      <description>stream transformations with predicates</description>
    </manifestation>
    <manifestation>
      <name>Elasticsearch Percolator</name>
      <description>stored queries matching incoming events</description>
    </manifestation>
    <manifestation>
      <name>AG-UI event filtering</name>
      <description>filtering 16 event types by user preferences</description>
    </manifestation>
  </manifestations>
</pattern>
