<?xml version="1.0" ?>
<pattern xmlns="http://universal-corpus.org/schema/v1" id="P58" version="1.1">
  <metadata>
    <name>Authentication Pattern</name>
    <category>pattern</category>
    <status>stable</status>
    <complexity>medium</complexity>
  </metadata>
  <definition>
    <tuple-notation format="latex">$A = (users, credentials, sessions, verify, tokens)$</tuple-notation>
    <components>
      <component>
        <name>users</name>
        <type>MapâŸ¨UserID, UserâŸ©</type>
        <notation>users</notation>
        <description>registered users</description>
      </component>
      <component>
        <name>credentials</name>
        <type>MapâŸ¨UserID, HashedPasswordâŸ©</type>
        <notation>credentials</notation>
        <description>store credentials</description>
      </component>
      <component>
        <name>sessions</name>
        <type>MapâŸ¨SessionID, SessionâŸ©</type>
        <notation>sessions</notation>
        <description>track active sessions</description>
      </component>
      <component>
        <name>verify</name>
        <type>(UserID, Password) â†’ ğ”¹</type>
        <notation>verify</notation>
        <description>validates credentials</description>
      </component>
      <component>
        <name>tokens</name>
        <type>MapâŸ¨Token, UserIDâŸ©</type>
        <notation>tokens</notation>
        <description>map tokens to users</description>
      </component>
    </components>
  </definition>
  <type-definitions>
    <type-def>
      <name>User</name>
      <definition format="latex">(id: UserID, username: String, email: String, roles: SetâŸ¨RoleâŸ©)</definition>
    </type-def>
    <type-def>
      <name>HashedPassword</name>
      <definition format="latex">String  // bcrypt, argon2, etc.</definition>
    </type-def>
    <type-def>
      <name>Session</name>
      <definition format="latex">(id: SessionID, user: UserID, created: Time, expires: Time, data: MapâŸ¨String,ValueâŸ©)</definition>
    </type-def>
    <type-def>
      <name>Token</name>
      <definition format="latex">String  // JWT, opaque token, etc.</definition>
    </type-def>
  </type-definitions>
  <properties>
    <property id="P.P58.1">
      <name>Secure Storage</name>
      <formal-spec format="latex">Passwords stored as secure hashes, never plaintext</formal-spec>
    </property>
    <property id="P.P58.2">
      <name>Session Expiration</name>
      <formal-spec format="latex">âˆ€session âˆˆ sessions: now() &gt; session.expires â‡’ invalid(session)</formal-spec>
    </property>
    <property id="P.P58.3">
      <name>Token Security</name>
      <formal-spec format="latex">Tokens cryptographically signed and time-limited</formal-spec>
    </property>
  </properties>
  <operations>
    <operation>
      <name>Register User</name>
      <signature>register(username: String, password: String, email: String) â†’ UserID</signature>
      <formal-definition format="latex">```
   register(username: String, password: String, email: String) â†’ UserID
   = user_id := generate_id()
     hashed := hash_password(password)
     users[user_id] := User(user_id, username, email, {})
     credentials[user_id] := hashed
     return user_id</formal-definition>
    </operation>
    <operation>
      <name>Authenticate</name>
      <signature>authenticate(username: String, password: String) â†’ Session | null</signature>
      <formal-definition format="latex">```
   authenticate(username: String, password: String) â†’ Session | null
   = user := find_user_by_username(username)
     if user = null:
       return null
     
     if verify_password(password, credentials[user.id]):
       session := create_session(user.id)
       sessions[session.id] := session
       return session
     else:
       return null</formal-definition>
    </operation>
    <operation>
      <name>Verify Password</name>
      <signature>verify_password(plain: String, hashed: HashedPassword) â†’ ğ”¹</signature>
      <formal-definition format="latex">```
   verify_password(plain: String, hashed: HashedPassword) â†’ ğ”¹
   = return hash_function(plain) = hashed</formal-definition>
    </operation>
    <operation>
      <name>Create Session</name>
      <signature>create_session(user_id: UserID) â†’ Session</signature>
      <formal-definition format="latex">```
   create_session(user_id: UserID) â†’ Session
   = session_id := generate_session_id()
     expires := now() + session_duration
     return Session(session_id, user_id, now(), expires, {})</formal-definition>
    </operation>
    <operation>
      <name>Validate Session</name>
      <signature>validate_session(session_id: SessionID) â†’ ğ”¹</signature>
      <formal-definition format="latex">```
   validate_session(session_id: SessionID) â†’ ğ”¹
   = if session_id âˆ‰ sessions:
       return false
     session := sessions[session_id]
     if now() &gt; session.expires:
       delete sessions[session_id]
       return false
     return true</formal-definition>
    </operation>
    <operation>
      <name>Generate Token (JWT)</name>
      <signature>generate_token(user_id: UserID) â†’ Token</signature>
      <formal-definition format="latex">```
   generate_token(user_id: UserID) â†’ Token
   = payload := {
       user_id: user_id,
       issued_at: now(),
       expires_at: now() + token_ttl
     }
     token := sign(payload, secret_key)
     tokens[token] := user_id
     return token</formal-definition>
    </operation>
    <operation>
      <name>Session-Based</name>
      <signature>Login â†’ Create session â†’ Store session ID in cookie</signature>
      <formal-definition format="latex">```
   Login â†’ Create session â†’ Store session ID in cookie
   Subsequent requests send session ID
   Server validates session</formal-definition>
    </operation>
    <operation>
      <name>Token-Based (JWT)</name>
      <signature>Login â†’ Generate JWT â†’ Send to client</signature>
      <formal-definition format="latex">```
   Login â†’ Generate JWT â†’ Send to client
   Client includes JWT in Authorization header
   Server validates JWT signature</formal-definition>
    </operation>
    <operation>
      <name>OAuth 2.0</name>
      <signature>Redirect to OAuth provider â†’ User authorizes</signature>
      <formal-definition format="latex">```
   Redirect to OAuth provider â†’ User authorizes
   Provider returns authorization code
   Exchange code for access token
   Use token for API requests</formal-definition>
    </operation>
    <operation>
      <name>Multi-Factor (MFA)</name>
      <signature/>
      <formal-definition format="latex">```
   Password (something you know)
   + TOTP/SMS code (something you have)
   + Biometric (something you are)
```
- Use bcrypt/argon2 for password hashing
- Implement rate limiting on login attempts
- Use HTTPS for all authentication traffic
- Rotate tokens/sessions regularly
- Implement CSRF protection
- Use secure cookie flags (HttpOnly, Secure, SameSite)</formal-definition>
    </operation>
  </operations>
  <manifestations>
    <manifestation>
      <name>User login systems</name>
    </manifestation>
    <manifestation>
      <name>API authentication</name>
    </manifestation>
    <manifestation>
      <name>SSO</name>
      <description>Single Sign-On</description>
    </manifestation>
    <manifestation>
      <name>Multi-factor authentication</name>
    </manifestation>
  </manifestations>
</pattern>
