id: P25
version: '1.1'
schema_version: '1.0'
metadata:
  name: Streaming Protocol
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $S = (producer, consumer, buffer, backpressure, state)$
  description: ''
  components:
  - name: producer
    type: Producer
    notation: producer
    description: generates data
  - name: consumer
    type: Consumer
    notation: consumer
    description: processes data
  - name: buffer
    type: Queue⟨Chunk⟩
    notation: buffer
    description: buffers data
  - name: backpressure
    type: Signal
    notation: backpressure
    description: controls flow rate
  - name: state
    type: \{\text{flowing}, \text{paused}, \text{ended}, \text{error}\}
    notation: state
    description: stream state
type_definitions:
- name: Producer
  definition: '(generate: () → Chunk | EndOfStream, pause: () → Effect, resume: () → Effect)'
  notation: 'Producer := (generate: () → Chunk | EndOfStream, pause: () → Effect, resume: () → Effect)'
- name: Consumer
  definition: '(consume: Chunk → Effect)'
  notation: 'Consumer := (consume: Chunk → Effect)'
- name: Chunk
  definition: Sequence⟨Byte⟩ | Value
  notation: Chunk := Sequence⟨Byte⟩ | Value
properties:
- id: P.P25.1
  name: Flow Control
  formal_spec: buffer full → pause producer → wait → resume producer
  description: ''
  invariants: []
- id: P.P25.2
  name: Chunk Ordering
  formal_spec: Chunks consumed in order produced
  description: ''
  invariants: []
- id: P.P25.3
  name: Graceful Termination
  formal_spec: Producer sends EndOfStream → consumer processes remaining chunks → close
  description: ''
  invariants: []
operations:
- name: Produce
  signature: produce() → Effect
  formal_definition: "```\n   produce() → Effect\n   = while state = flowing:\n       chunk := producer.generate()\n\
    \       if chunk = EndOfStream:\n         state := ended\n         consumer.close()\n       else:\n\
    \         buffer := enqueue(buffer, chunk)\n         if buffer.size ≥ highWaterMark:\n           state\
    \ := paused\n           producer.pause()"
  preconditions: []
  postconditions: []
  effects: []
- name: Consume
  signature: consume() → Effect
  formal_definition: "```\n   consume() → Effect\n   = while ¬empty(buffer):\n       chunk := dequeue(buffer)\n\
    \       consumer.consume(chunk)\n       if buffer.size < lowWaterMark ∧ state = paused:\n        \
    \ state := flowing\n         producer.resume()"
  preconditions: []
  postconditions: []
  effects: []
- name: Readable Stream
  signature: ''
  formal_definition: "```\n   Data source (file, network)\n   Can only read from"
  preconditions: []
  postconditions: []
  effects: []
- name: Writable Stream
  signature: ''
  formal_definition: "```\n   Data sink (file, response)\n   Can only write to"
  preconditions: []
  postconditions: []
  effects: []
- name: Transform Stream
  signature: ''
  formal_definition: "```\n   Readable + Writable\n   Transforms data in flight\n   Example: compression,\
    \ encryption"
  preconditions: []
  postconditions: []
  effects: []
- name: Duplex Stream
  signature: ''
  formal_definition: "```\n   Independent readable and writable\n   Example: WebSocket"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: WebSocket
  description: ''
- name: Live updates
  description: ''
- name: Progressive rendering
  description: ''
- name: File uploads/downloads
  description: ''
- name: Video streaming
  description: ''
