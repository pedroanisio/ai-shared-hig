id: P55
version: '1.1'
schema_version: '1.0'
metadata:
  name: Virtualization Pattern
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $V = (data, viewport, item\_height, buffer, visible)$
  description: ''
  components:
  - name: data
    type: Sequence⟨Item⟩
    notation: data
    description: full dataset
  - name: viewport
    type: Rectangle
    notation: viewport
    description: visible area
  - name: item\_height
    type: Item → ℝ
    notation: item\_height
    description: calculates item height
  - name: buffer
    type: ℕ
    notation: buffer
    description: number of items to pre-render beyond viewport
  - name: visible
    type: Sequence⟨Item⟩
    notation: visible
    description: currently rendered items
type_definitions: []
properties:
- id: P.P55.1
  name: Minimal Rendering
  formal_spec: '|visible| ≪ |data|

    Only render items in viewport ± buffer'
  description: ''
  invariants: []
- id: P.P55.2
  name: Scroll Performance
  formal_spec: scroll_event → update_visible() completes in < 16ms
  description: ''
  invariants: []
- id: P.P55.3
  name: Memory Efficiency
  formal_spec: memory_usage = O(|visible|), not O(|data|)
  description: ''
  invariants: []
- id: P.P55.4
  name: Content Height
  formal_spec: total_height = ∑_{item ∈ data} item_height(item)
  description: ''
  invariants: []
operations:
- name: Calculate Visible Items
  signature: 'calculate_visible(scroll_top: ℝ) → (start: ℕ, end: ℕ)'
  formal_definition: "```\n   calculate_visible(scroll_top: ℝ) → (start: ℕ, end: ℕ)\n   = start_idx :=\
    \ binary_search(data, λi:\n       cumulative_height(data[0:i]) ≥ scroll_top - buffer_height\n    \
    \ )\n     end_idx := binary_search(data, λi:\n       cumulative_height(data[0:i]) ≥ scroll_top + viewport.height\
    \ + buffer_height\n     )\n     return (start_idx, end_idx)"
  preconditions: []
  postconditions: []
  effects: []
- name: Update On Scroll
  signature: 'on_scroll(scroll_top: ℝ) → Effect'
  formal_definition: "```\n   on_scroll(scroll_top: ℝ) → Effect\n   = (start, end) := calculate_visible(scroll_top)\n\
    \     visible := data[start:end]\n     offset := cumulative_height(data[0:start])\n     render(visible,\
    \ offset)"
  preconditions: []
  postconditions: []
  effects: []
- name: Handle Variable Heights
  signature: ''
  formal_definition: "```\n   For variable item heights:\n     - Maintain height cache: Map⟨ℕ, ℝ⟩\n  \
    \   - Estimate unknown heights\n     - Measure rendered items\n     - Update cache and reflow if necessary\n\
    4. Fixed Height:**\n```\n   All items same height\n   Simplest and most performant"
  preconditions: []
  postconditions: []
  effects: []
- name: Variable Height (Estimated)
  signature: ''
  formal_definition: "```\n   Estimate heights before rendering\n   Adjust on actual measurement"
  preconditions: []
  postconditions: []
  effects: []
- name: Dynamic Height
  signature: ''
  formal_definition: "```\n   Measure items as they render\n   Maintain running height cache\n   Update\
    \ scroll container size\n```\n1. Overscan buffer:\n   Render N items beyond viewport\n   Reduces blank\
    \ areas during fast scroll\n\n2. Debounced updates:\n   Wait τ ms after scroll stops\n   Reduces re-renders\
    \ during scroll\n\n3. Recycled DOM:\n   Reuse DOM nodes for different items\n   Reduces GC pressure\n\
    \n4. Intersection Observer:\n   Use native API for visibility detection\n   Better performance than\
    \ scroll events"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Large lists
  description: 1000+ items
- name: Data grids
  description: ''
- name: Feed viewers
  description: social media
- name: Log viewers
  description: ''
- name: File explorers
  description: ''
