id: F6
version: '1.1'
schema_version: '1.0'
metadata:
  name: Error Recovery Flow
  category: flow
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $E = (detect, classify, strategy, recover)$
  description: ''
  components:
  - name: detect
    type: Operation → Error | Success
    notation: detect
    description: catches errors
  - name: classify
    type: Error → ErrorType
    notation: classify
    description: determines error category
  - name: strategy
    type: ErrorType → RecoveryStrategy
    notation: strategy
    description: selects recovery approach
  - name: recover
    type: (Error, RecoveryStrategy) → Effect
    notation: recover
    description: executes recovery
type_definitions:
- name: ErrorType
  definition: Transient | Permanent | Recoverable
  notation: ErrorType := Transient | Permanent | Recoverable
- name: RecoveryStrategy
  definition: 'Retry(max: ℕ, backoff: Time → Time) |'
  notation: 'RecoveryStrategy := Retry(max: ℕ, backoff: Time → Time) |'
- name: Operation
  definition: () → Result | Error
  notation: Operation := () → Result | Error
properties:
- id: P.F6.1
  name: Error Classification
  formal_spec: '∀e ∈ Error: classify(e) determines appropriate recovery strategy

    Transient → Retry

    Permanent → Report

    Recoverable → Fallback | GracefulDegradation'
  description: ''
  invariants: []
- id: P.F6.2
  name: Recovery Exhaustion
  formal_spec: '∀recovery_attempt: attempts ≤ max_attempts ∨ escalate(error)'
  description: ''
  invariants: []
- id: P.F6.3
  name: State Safety
  formal_spec: '∀e ∈ Error: recover(e) preserves system invariants

    No partial state corruption'
  description: ''
  invariants: []
operations:
- name: Retry with Backoff
  signature: 'retry(operation: Operation, max_attempts: ℕ) → Result | Error'
  formal_definition: "```\n   retry(operation: Operation, max_attempts: ℕ) → Result | Error\n   = attempts\
    \ := 0\n     while attempts < max_attempts:\n       try:\n         return operation()\n       catch\
    \ error:\n         if transient(error):\n           wait(2^attempts · base_delay)\n           attempts\
    \ := attempts + 1\n         else:\n           throw error\n     throw MaxAttemptsExceeded"
  preconditions: []
  postconditions: []
  effects: []
- name: Circuit Breaker
  signature: 'circuit_breaker(operation: Operation, threshold: ℕ) → Result | Error'
  formal_definition: "```\n   circuit_breaker(operation: Operation, threshold: ℕ) → Result | Error\n \
    \  = state := Closed\n     failures := 0\n     \n     execute():\n       case state of\n         Closed\
    \ → \n           try:\n             result := operation()\n             failures := 0\n          \
    \   return result\n           catch error:\n             failures := failures + 1\n             if\
    \ failures ≥ threshold:\n               state := Open\n               schedule_half_open(timeout)\n\
    \             throw error\n         Open → throw CircuitOpenError\n         HalfOpen →\n         \
    \  try:\n             result := operation()\n             state := Closed\n             return result\n\
    \           catch error:\n             state := Open\n             throw error"
  preconditions: []
  postconditions: []
  effects: []
- name: Graceful Degradation
  signature: 'degrade(levels: Sequence⟨Mode⟩, operation: Mode → Result) → Result'
  formal_definition: "```\n   degrade(levels: Sequence⟨Mode⟩, operation: Mode → Result) → Result\n   =\
    \ for mode in levels:\n       try:\n         return operation(mode)\n       catch error:\n       \
    \  continue\n     throw AllModesFailedError"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Network request retry
  description: HTTP clients with backoff
- name: File load fallback
  description: multiple locations/mirrors
- name: Service degradation
  description: cache → static → error
- name: Database connection pooling
  description: retry on transient failures
- name: User retry prompts
  description: try again button
