id: P56
version: '1.1'
schema_version: '1.0'
metadata:
  name: Cache Strategy Pattern
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $C = (storage, policy, ttl, evict)$
  description: ''
  components:
  - name: storage
    type: Map⟨Key, (Value, Metadata)⟩
    notation: storage
    description: cache store
  - name: policy
    type: EvictionPolicy
    notation: policy
    description: determines what to evict
  - name: ttl
    type: Key → Duration
    notation: ttl
    description: defines time-to-live
  - name: evict
    type: () → Effect
    notation: evict
    description: removes stale entries
type_definitions:
- name: EvictionPolicy
  definition: LRU | LFU | FIFO | TTL | Custom
  notation: EvictionPolicy := LRU | LFU | FIFO | TTL | Custom
- name: Metadata
  definition: '(last_accessed: Time, access_count: ℕ, inserted: Time)'
  notation: 'Metadata := (last_accessed: Time, access_count: ℕ, inserted: Time)'
- name: Duration
  definition: ℕ  // milliseconds
  notation: Duration := ℕ  // milliseconds
properties:
- id: P.P56.1
  name: Bounded Size
  formal_spec: '|storage| ≤ max_size'
  description: ''
  invariants: []
- id: P.P56.2
  name: Cache Hit
  formal_spec: get(key) → O(1) if key ∈ storage
  description: ''
  invariants: []
- id: P.P56.3
  name: Automatic Eviction
  formal_spec: '|storage| = max_size ∧ insert(new_key) → evict() → insert(new_key)'
  description: ''
  invariants: []
operations:
- name: Get (with Cache-Through)
  signature: 'get(key: Key, load: () → Value) → Value'
  formal_definition: "```\n   get(key: Key, load: () → Value) → Value\n   = if key ∈ storage ∧ ¬expired(key):\n\
    \       update_metadata(key)\n       return storage[key].value\n     else:\n       value := load()\n\
    \       set(key, value)\n       return value"
  preconditions: []
  postconditions: []
  effects: []
- name: Set
  signature: 'set(key: Key, value: Value) → Effect'
  formal_definition: "```\n   set(key: Key, value: Value) → Effect\n   = if |storage| = max_size:\n  \
    \     evict()\n     storage[key] := (value, Metadata(now(), 0, now()))"
  preconditions: []
  postconditions: []
  effects: []
- name: Evict
  signature: evict() → Effect
  formal_definition: "```\n   evict() → Effect\n   = victim := select_victim(policy)\n     delete storage[victim]\n\
    \   \n   select_victim(LRU) = key with oldest last_accessed\n   select_victim(LFU) = key with lowest\
    \ access_count\n   select_victim(TTL) = oldest expired key"
  preconditions: []
  postconditions: []
  effects: []
- name: Cache-Aside
  signature: ''
  formal_definition: "```\n   Application checks cache\n   On miss: load from DB, populate cache\n   On\
    \ hit: return cached value"
  preconditions: []
  postconditions: []
  effects: []
- name: Read-Through
  signature: ''
  formal_definition: "```\n   Cache automatically loads on miss\n   Application only talks to cache"
  preconditions: []
  postconditions: []
  effects: []
- name: Write-Through
  signature: ''
  formal_definition: "```\n   Writes go to cache and DB simultaneously\n   Ensures consistency"
  preconditions: []
  postconditions: []
  effects: []
- name: Write-Behind
  signature: ''
  formal_definition: "```\n   Writes go to cache immediately\n   Async writeback to DB\n   Better write\
    \ performance"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Browser cache
  description: ''
- name: CDN caching
  description: ''
- name: Database query cache
  description: ''
- name: Computed value cache
  description: ''
- name: Image thumbnails
  description: ''
