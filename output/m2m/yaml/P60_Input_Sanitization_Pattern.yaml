id: P60
version: '1.1'
schema_version: '1.0'
metadata:
  name: Input Sanitization Pattern
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $S = (validators, sanitizers, encoders, rules)$
  description: ''
  components:
  - name: validators
    type: Map⟨InputType, Validator⟩
    notation: validators
    description: check input validity
  - name: sanitizers
    type: Map⟨InputType, Sanitizer⟩
    notation: sanitizers
    description: clean input
  - name: encoders
    type: Map⟨Context, Encoder⟩
    notation: encoders
    description: encode for safe output
  - name: rules
    type: Set⟨SecurityRule⟩
    notation: rules
    description: define security constraints
type_definitions:
- name: InputType
  definition: Text | HTML | SQL | URL | Email | ...
  notation: InputType := Text | HTML | SQL | URL | Email | ...
- name: Validator
  definition: Input → ValidationResult
  notation: Validator := Input → ValidationResult
- name: Sanitizer
  definition: Input → SanitizedInput
  notation: Sanitizer := Input → SanitizedInput
- name: Encoder
  definition: Input → EncodedOutput
  notation: Encoder := Input → EncodedOutput
- name: SecurityRule
  definition: '(pattern: Regex, action: Block | Sanitize | Warn)'
  notation: 'SecurityRule := (pattern: Regex, action: Block | Sanitize | Warn)'
properties:
- id: P.P60.1
  name: Defense in Depth
  formal_spec: 'Multiple layers: validate → sanitize → encode'
  description: ''
  invariants: []
- id: P.P60.2
  name: Whitelist Over Blacklist
  formal_spec: Allow known-good patterns rather than blocking known-bad
  description: ''
  invariants: []
- id: P.P60.3
  name: Context-Appropriate Encoding
  formal_spec: 'HTML context → HTML encode

    SQL context → Parameterized queries

    URL context → URL encode'
  description: ''
  invariants: []
operations:
- name: Validate Input
  signature: 'validate(input: Input, type: InputType) → ValidationResult'
  formal_definition: "```\n   validate(input: Input, type: InputType) → ValidationResult\n   = validator\
    \ := validators[type]\n     result := validator(input)\n     if result = Invalid:\n       log_security_event(\"\
    Invalid input\", input, type)\n     return result"
  preconditions: []
  postconditions: []
  effects: []
- name: Sanitize Input
  signature: 'sanitize(input: Input, type: InputType) → Input'
  formal_definition: "```\n   sanitize(input: Input, type: InputType) → Input\n   = sanitizer := sanitizers[type]\n\
    \     return sanitizer(input)"
  preconditions: []
  postconditions: []
  effects: []
- name: Encode Output
  signature: 'encode(input: Input, context: Context) → String'
  formal_definition: "```\n   encode(input: Input, context: Context) → String\n   = encoder := encoders[context]\n\
    \     return encoder(input)"
  preconditions: []
  postconditions: []
  effects: []
- name: XSS (Cross-Site Scripting)
  signature: ''
  formal_definition: "```\n   Vulnerability: <script>alert('xss')</script>\n   Defense:\n     - Validate:\
    \ Allow only expected characters\n     - Sanitize: Remove script tags\n     - Encode: &lt;script&gt;\
    \ in HTML context\n   \n   encode_html(text: String) → String\n   = replace(text, [\n       (\"<\"\
    , \"&lt;\"),\n       (\">\", \"&gt;\"),\n       (\"&\", \"&amp;\"),\n       (\"\\\"\", \"&quot;\"\
    ),\n       (\"'\", \"&#x27;\")\n     ])"
  preconditions: []
  postconditions: []
  effects: []
- name: SQL Injection
  signature: ''
  formal_definition: "```\n   Vulnerability: '; DROP TABLE users; --\n   Defense:\n     - Use parameterized\
    \ queries (prepared statements)\n     - Never concatenate user input into SQL\n     - Validate input\
    \ type\n   \n   Safe:\n     query = \"SELECT * FROM users WHERE id = ?\"\n     execute(query, [user_input])\n\
    \   \n   Unsafe:\n     query = \"SELECT * FROM users WHERE id = \" + user_input"
  preconditions: []
  postconditions: []
  effects: []
- name: Path Traversal
  signature: ''
  formal_definition: "```\n   Vulnerability: ../../etc/passwd\n   Defense:\n     - Validate: Only allow\
    \ alphanumeric + safe chars\n     - Sanitize: Remove .. and /\n     - Use whitelist of allowed paths\n\
    \   \n   sanitize_path(path: String) → String\n   = normalized := normalize(path)\n     if contains(normalized,\
    \ \"..\") ∨ starts_with(normalized, \"/\"):\n       throw SecurityException(\"Invalid path\")\n  \
    \   return join(base_dir, normalized)"
  preconditions: []
  postconditions: []
  effects: []
- name: Command Injection
  signature: ''
  formal_definition: "```\n   Vulnerability: ; rm -rf /\n   Defense:\n     - Never pass user input to\
    \ shell\n     - Use language APIs instead of shell commands\n     - Validate against whitelist\n \
    \  \n   Safe:\n     delete_file(filename)  // Use API\n   \n   Unsafe:\n     exec(\"rm \" + filename)\
    \  // Shell command"
  preconditions: []
  postconditions: []
  effects: []
- name: LDAP Injection
  signature: ''
  formal_definition: "```\n   Vulnerability: *)(uid=*))(|(uid=*\n   Defense:\n     - Escape special characters:\
    \ * ( ) \\ / NUL\n     - Use parameterized LDAP queries\n   \n   escape_ldap(input: String) → String\n\
    \   = replace(input, [\n       (\"*\", \"\\\\2a\"),\n       (\"(\", \"\\\\28\"),\n       (\")\", \"\
    \\\\29\"),\n       (\"\\\\\", \"\\\\5c\"),\n       (\"/\", \"\\\\2f\")\n     ])\n```\nEmail:\n  pattern:\
    \ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$\n\nURL:\n  pattern: ^https?://[a-zA-Z0-9.-]+\\\
    .[a-zA-Z]{2,}(/.*)?$\n  validate_protocol: must be http or https\n\nUsername:\n  pattern: ^[a-zA-Z0-9_-]{3,20}$\n\
    \  length: 3-20 characters\n  chars: alphanumeric, underscore, hyphen\n\nPhone:\n  pattern: ^\\+?[1-9]\\\
    d{1,14}$\n  format: E.164 international format"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Form input validation
  description: ''
- name: API input sanitization
  description: ''
- name: Template rendering
  description: auto-escaping
- name: Database query builders
  description: ''
