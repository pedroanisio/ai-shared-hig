id: P61
version: '1.1'
schema_version: '1.0'
metadata:
  name: Unit Test Pattern
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $U = (sut, arrange, act, assert, cleanup)$
  description: ''
  components:
  - name: sut
    type: System
    notation: sut
    description: '**system under test** (unit being tested)'
  - name: arrange
    type: () → Context
    notation: arrange
    description: sets up test preconditions
  - name: act
    type: Context → Result
    notation: act
    description: exercises the unit
  - name: assert
    type: Result → \mathbb{B}
    notation: assert
    description: verifies expectations
  - name: cleanup
    type: Context → Effect
    notation: cleanup
    description: tears down test state
type_definitions:
- name: System
  definition: Function | Class | Module
  notation: System := Function | Class | Module
- name: Context
  definition: '(mocks: Set⟨Mock⟩, fixtures: Set⟨Fixture⟩, state: State)'
  notation: 'Context := (mocks: Set⟨Mock⟩, fixtures: Set⟨Fixture⟩, state: State)'
- name: Mock
  definition: '(target: Dependency, behavior: Specification)'
  notation: 'Mock := (target: Dependency, behavior: Specification)'
- name: Fixture
  definition: '(data: Data, setup: () → Effect, teardown: () → Effect)'
  notation: 'Fixture := (data: Data, setup: () → Effect, teardown: () → Effect)'
properties:
- id: P.P61.1
  name: Isolation
  formal_spec: 'Unit tests run independently

    No shared state between tests'
  description: ''
  invariants: []
- id: P.P61.2
  name: Fast Execution
  formal_spec: 'Unit tests complete in milliseconds

    No I/O, network, or database'
  description: ''
  invariants: []
- id: P.P61.3
  name: Repeatability
  formal_spec: Same input → same output (deterministic)
  description: ''
  invariants: []
- id: P.P61.4
  name: Single Assertion Focus
  formal_spec: 'Each test verifies one behavior

    Clear failure messages'
  description: ''
  invariants: []
operations:
- name: Execute Test
  signature: 'execute_test(test: Test) → TestResult'
  formal_definition: "```\n   execute_test(test: Test) → TestResult\n   = context := test.arrange()\n\
    \     result := test.act(context)\n     passed := test.assert(result)\n     test.cleanup(context)\n\
    \     return TestResult(passed, result, context)"
  preconditions: []
  postconditions: []
  effects: []
- name: Run Test Suite
  signature: 'run_suite(tests: Set⟨Test⟩) → SuiteResult'
  formal_definition: "```\n   run_suite(tests: Set⟨Test⟩) → SuiteResult\n   = results := []\n     for\
    \ test in tests:\n       result := execute_test(test)\n       results := results ∪ {result}\n    \
    \ return SuiteResult(results, summary(results))"
  preconditions: []
  postconditions: []
  effects: []
- name: Mock Dependency
  signature: 'mock(dependency: Dependency, behavior: Specification) → Mock'
  formal_definition: "```\n   mock(dependency: Dependency, behavior: Specification) → Mock\n   = mock\
    \ := Mock(dependency)\n     configure(mock, behavior)\n     return mock\n```\ntest_addition() → \U0001D539\
    \n  // Arrange: Set up test data\n  = calculator := Calculator()\n    a := 2\n    b := 3\n    expected\
    \ := 5\n    \n    // Act: Exercise the unit\n    result := calculator.add(a, b)\n    \n    // Assert:\
    \ Verify expectations\n    assert(result = expected, \"2 + 3 should equal 5\")\n    \n    // Cleanup\
    \ (if needed)\n    cleanup()\n```\nMock dependency behavior:\n  mock_database := Mock(Database)\n\
    \  mock_database.when(get_user(1)).then_return(User(1, \"Alice\"))\n  \n  service := UserService(mock_database)\n\
    \  user := service.get_user(1)\n  \n  assert(user.name = \"Alice\")\n  verify(mock_database.get_user).called_once_with(1)"
  preconditions: []
  postconditions: []
  effects: []
- name: Given-When-Then (BDD style)
  signature: ''
  formal_definition: "```\n   test_user_login()\n     Given: user exists with username \"alice\" and password\
    \ \"secret\"\n     When: user logs in with correct credentials\n     Then: login succeeds and session\
    \ is created"
  preconditions: []
  postconditions: []
  effects: []
- name: Table-Driven Tests
  signature: ''
  formal_definition: "```\n   test_cases := [\n     (input: 2, expected: 4),\n     (input: 3, expected:\
    \ 9),\n     (input: 4, expected: 16)\n   ]\n   \n   for (input, expected) in test_cases:\n     result\
    \ := square(input)\n     assert(result = expected)"
  preconditions: []
  postconditions: []
  effects: []
- name: Parameterized Tests
  signature: ''
  formal_definition: "```\n   @parameterized([\n     (2, 3, 5),\n     (10, 5, 15),\n     (-1, 1, 0)\n\
    \   ])\n   test_addition(a, b, expected)\n     result := add(a, b)\n     assert(result = expected)\n\
    ```\nassert_equal(actual, expected)\nassert_not_equal(actual, not_expected)\nassert_true(condition)\n\
    assert_false(condition)\nassert_null(value)\nassert_not_null(value)\nassert_contains(collection, item)\n\
    assert_raises(exception_type, callable)\nassert_almost_equal(actual, expected, tolerance)"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Unit tests
  description: pytest, Jest, JUnit
- name: TDD
  description: Test-Driven Development
- name: Component tests
  description: ''
- name: Function tests
  description: ''
