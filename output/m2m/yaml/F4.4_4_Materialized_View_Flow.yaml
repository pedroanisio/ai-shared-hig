id: ''
version: '1.1'
schema_version: '1.0'
metadata:
  name: ''
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $M = (query, compute, cache, refresh)$
  description: ''
  components:
  - name: query
    type: Query
    notation: query
    description: defines the view computation
  - name: compute
    type: Data → Result
    notation: compute
    description: executes the query
  - name: cache
    type: Result
    notation: cache
    description: stores computed result
  - name: refresh
    type: Trigger → Effect
    notation: refresh
    description: updates materialized view
type_definitions:
- name: Query
  definition: '(select: Projection, from: Source, where: Predicate, aggregate: Function)'
  notation: 'Query := (select: Projection, from: Source, where: Predicate, aggregate: Function)'
- name: Result
  definition: Computed and cached query result
  notation: Result := Computed and cached query result
- name: Trigger
  definition: 'OnDemand | OnChange | Scheduled(interval: Time)'
  notation: 'Trigger := OnDemand | OnChange | Scheduled(interval: Time)'
- name: Staleness
  definition: Time since last refresh
  notation: Staleness := Time since last refresh
properties:
- id: P.F4.4.1
  name: Consistency Eventually
  formal_spec: '∀m ∈ MaterializedViews: after_refresh(m) ⇒

    cache(m) = compute(query(m), current_data)'
  description: ''
  invariants: []
- id: P.F4.4.2
  name: Performance Trade-off
  formal_spec: 'read_cost(materialized_view) << read_cost(base_query) ∧

    maintenance_cost(materialized_view) > 0'
  description: ''
  invariants: []
- id: P.F4.4.3
  name: Staleness Bound
  formal_spec: '∀m ∈ MaterializedViews: staleness(m) ≤ max_staleness(m) ∨ trigger_refresh(m)'
  description: ''
  invariants: []
operations:
- name: Read
  signature: 'read(view: MaterializedView) → Result'
  formal_definition: "```\n   read(view: MaterializedView) → Result\n   = if stale(view):\n       if refresh_strategy\
    \ = OnDemand:\n         refresh(view)\n     return cache[view]"
  preconditions: []
  postconditions: []
  effects: []
- name: Refresh
  signature: 'refresh(view: MaterializedView) → Effect'
  formal_definition: "```\n   refresh(view: MaterializedView) → Effect\n   = start_transaction()\n   \
    \  new_result := compute(view.query, current_data)\n     cache[view] := new_result\n     last_refreshed[view]\
    \ := now()\n     commit_transaction()\n     notify_subscribers(view)"
  preconditions: []
  postconditions: []
  effects: []
- name: Incremental Refresh
  signature: 'incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect'
  formal_definition: "```\n   incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect\n\
    \   = affected := filter_relevant_changes(changes, view.query)\n     if empty(affected):\n       return\
    \  // No update needed\n     \n     if can_update_incrementally(view, affected):\n       cache[view]\
    \ := apply_incremental_update(cache[view], affected)\n     else:\n       refresh(view)  // Full refresh"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: Database materialized views
  description: ''
- name: Cached aggregations
  description: ''
- name: Precomputed reports
  description: ''
- name: Search indices
  description: ''
- name: Dashboard metrics
  description: ''
