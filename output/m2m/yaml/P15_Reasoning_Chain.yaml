id: P15
version: '1.1'
schema_version: '1.0'
metadata:
  name: Reasoning Chain
  category: pattern
  status: stable
  complexity: medium
  domains: []
definition:
  tuple_notation: $R = (steps, state, deps, result)$
  description: ''
  components:
  - name: steps
    type: Sequence⟨Step⟩
    notation: steps
    description: reasoning steps
  - name: state
    type: Map⟨ℕ, State⟩
    notation: state
    description: tracks state at each step
  - name: deps
    type: Map⟨ℕ, Set⟨ℕ⟩⟩
    notation: deps
    description: defines step dependencies
  - name: result
    type: Result
    notation: result
    description: final conclusion
type_definitions:
- name: Step
  definition: '(id: ℕ, operation: Operation, inputs: Set⟨ℕ⟩, output: Value)'
  notation: 'Step := (id: ℕ, operation: Operation, inputs: Set⟨ℕ⟩, output: Value)'
- name: Operation
  definition: Infer | Deduce | Calculate | Verify | ...
  notation: Operation := Infer | Deduce | Calculate | Verify | ...
- name: State
  definition: Map⟨String, Value⟩  // Variable bindings
  notation: State := Map⟨String, Value⟩  // Variable bindings
properties:
- id: P.P15.1
  name: Sequential Dependency
  formal_spec: step_i depends on step_j ⇒ j < i (executed before)
  description: ''
  invariants: []
- id: P.P15.2
  name: State Evolution
  formal_spec: state[i+1] = apply(step[i], state[i])
  description: ''
  invariants: []
- id: P.P15.3
  name: Conclusion Derivation
  formal_spec: result derived from state[|steps|]
  description: ''
  invariants: []
operations:
- name: Add Step
  signature: 'add_step(operation: Operation, inputs: Set⟨ℕ⟩) → ℕ'
  formal_definition: "```\n   add_step(operation: Operation, inputs: Set⟨ℕ⟩) → ℕ\n   = step_id := |steps|\n\
    \     step := Step(step_id, operation, inputs, unknown)\n     steps := steps ++ [step]\n     return\
    \ step_id"
  preconditions: []
  postconditions: []
  effects: []
- name: Execute Chain
  signature: execute() → Result
  formal_definition: "```\n   execute() → Result\n   = state[0] := initial_state\n     for i in 0..|steps|:\n\
    \       input_values := {state[j][steps[j].output] : j ∈ steps[i].inputs}\n       output := steps[i].operation(input_values)\n\
    \       state[i+1] := state[i] ∪ {steps[i].output: output}\n     return state[|steps|]"
  preconditions: []
  postconditions: []
  effects: []
manifestations:
- name: AI reasoning
  description: chain-of-thought
- name: Proof derivation
  description: ''
- name: Build pipelines
  description: ''
- name: Computation traces
  description: ''
