### F4.4 Materialized View Flow

**Definition F4.4:**
A materialized view flow is a tuple $M = (query, compute, cache, refresh)$ where:
- $query : Query$ defines the view computation
- $compute : Data → Result$ executes the query
- $cache : Result$ stores computed result
- $refresh : Trigger → Effect$ updates materialized view

**Type Definitions:**
```
Query := (select: Projection, from: Source, where: Predicate, aggregate: Function)
Result := Computed and cached query result
Trigger := OnDemand | OnChange | Scheduled(interval: Time)
Staleness := Time since last refresh
```

**Properties:**

**P.F4.4.1 (Consistency Eventually):**
```
∀m ∈ MaterializedViews: after_refresh(m) ⇒ 
  cache(m) = compute(query(m), current_data)
```

**P.F4.4.2 (Performance Trade-off):**
```
read_cost(materialized_view) << read_cost(base_query) ∧
maintenance_cost(materialized_view) > 0
```

**P.F4.4.3 (Staleness Bound):**
```
∀m ∈ MaterializedViews: staleness(m) ≤ max_staleness(m) ∨ trigger_refresh(m)
```

**Operations:**

1. **Read:**
   ```
   read(view: MaterializedView) → Result
   = if stale(view):
       if refresh_strategy = OnDemand:
         refresh(view)
     return cache[view]
   ```

2. **Refresh:**
   ```
   refresh(view: MaterializedView) → Effect
   = start_transaction()
     new_result := compute(view.query, current_data)
     cache[view] := new_result
     last_refreshed[view] := now()
     commit_transaction()
     notify_subscribers(view)
   ```

3. **Incremental Refresh:**
   ```
   incremental_refresh(view: MaterializedView, changes: Set⟨Change⟩) → Effect
   = affected := filter_relevant_changes(changes, view.query)
     if empty(affected):
       return  // No update needed
     
     if can_update_incrementally(view, affected):
       cache[view] := apply_incremental_update(cache[view], affected)
     else:
       refresh(view)  // Full refresh
   ```

**Manifestations:**
- Database materialized views
- Cached aggregations
- Precomputed reports
- Search indices
- Dashboard metrics

---

