### F2.3 Incremental Computation Flow

**Definition F2.3:**
An incremental computation flow is a tuple $I = (graph, cache, invalidate, recompute)$ where:
- $graph : DAG⟨Node, Dependency⟩$ is the computation dependency graph
- $cache : Map⟨Node, Value⟩$ stores computed values
- $invalidate : Node → Set⟨Node⟩$ marks affected nodes
- $recompute : Node → Value$ recomputes a single node

**Type Definitions:**
```
Node := (id: String, compute: Inputs → Output, dependencies: Set⟨Node⟩)
Dependency := (source: Node, target: Node)
DAG⟨N, E⟩ := Directed Acyclic Graph
```

**Properties:**

**P.F2.3.1 (Minimal Recomputation):**
```
∀n ∈ graph: recompute(n) ⇔ (invalidated(n) ∨ ∃d ∈ dependencies(n): invalidated(d))
Only recompute what changed
```

**P.F2.3.2 (Topological Order):**
```
∀n₁, n₂: dependency(n₁, n₂) ⇒ compute_order(n₁) < compute_order(n₂)
```

**P.F2.3.3 (Cache Consistency):**
```
∀n ∈ graph: cache[n] = last_computed_value(n) ∨ cache[n] = ⊥
```

**Operations:**

1. **Update:**
   ```
   update(changed: Set⟨Node⟩) → Effect
   = affected := transitive_dependencies(changed)
     invalidate(affected)
     sorted := topological_sort(affected)
     for node in sorted:
       cache[node] := recompute(node)
   ```

2. **Invalidate:**
   ```
   invalidate(nodes: Set⟨Node⟩) → Set⟨Node⟩
   = invalidated := nodes
     for node in nodes:
       for dependent in dependents(node):
         invalidated := invalidated ∪ invalidate({dependent})
     return invalidated
   ```

3. **Recompute:**
   ```
   recompute(node: Node) → Value
   = inputs := {cache[d] : d ∈ dependencies(node)}
     return node.compute(inputs)
   ```

**Manifestations:**
- Spreadsheet recalculation
- Build systems (Make, Bazel)
- Reactive frameworks (React, Vue)
- Query optimization
- Dataflow programming

---

